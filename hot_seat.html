<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Backgammon</title>
    <link rel="stylesheet" href="{{url_for('static', filename='gra.css')}}">
</head>
<body>
    <h2>Hot-seat mode</h2>
    <button id="end-turn-btn">Zakończ turę</button>
    <div id="captured-pieces" class="captured-area">
      <h3>Captured Pieces</h3>
  </div>
  <div class="dice-container">
    <div class="dice" id="die1">1</div>
    <div class="dice" id="die2">6</div>
    <h3 id="turn-indicator">Tura gracza: 1 (Białe)</h3>
  </div>
  
    <div class="game-wrapper">
        <!-- Plansza Backgammon -->
        <div class="board">
          <!-- Top row: punkty 24 do 13 -->
          <div class="row top-row">
            <!-- Punkt 24: 2 białe pionki -->
            <div class="point" data-position="13">
              <span class="point-number">13</span>
              <div class="triangle" id="point-13"></div>
              <div class="piece white" data-position="13"></div>
              <div class="piece white" data-position="13"></div>
              <div class="piece white" data-position="13"></div>
              <div class="piece white" data-position="13"></div>
              <div class="piece white" data-position="13"></div>
            </div>
            <!-- Punkt 23: pusty -->
            <div class="point" data-position="14">
              <span class="point-number">14</span>
              <div class="triangle" id="point-14"></div>
            </div>
            <!-- Punkt 22: pusty -->
            <div class="point" data-position="15">
              <span class="point-number">15</span>
              <div class="triangle" id="point-15"></div>
            </div>
            <!-- Punkt 21: pusty -->
            <div class="point" data-position="16">
              <span class="point-number">16</span>
              <div class="triangle" id="point-16"></div>
            </div>
            <!-- Punkt 20: pusty -->
            <div class="point" data-position="17">
              <span class="point-number">17</span>
              <div class="triangle" id="point-17"></div>
              <div class="piece black" data-position="17"></div>
              <div class="piece black" data-position="17"></div>
              <div class="piece black" data-position="17"></div>
            </div>
            <!-- Punkt 19: 5 czarnych pionków -->
            <div class="point" data-position="18">
              <span class="point-number">18</span>
              <div class="triangle" id="point-18"></div>
              
            </div>
            <!-- Punkt 18: pusty -->
            <div class="point" data-position="19">
              <span class="point-number">19</span>
              <div class="triangle" id="point-19"></div>
              <div class="piece black" data-position="19"></div>
              <div class="piece black" data-position="19"></div>
              <div class="piece black" data-position="19"></div>
              <div class="piece black" data-position="19"></div>
              <div class="piece black" data-position="19"></div>
            </div>
            <!-- Punkt 17: 3 czarne pionki -->
            <div class="point" data-position="20">
              <span class="point-number">20</span>
              <div class="triangle" id="point-20"></div>
            </div>
            <!-- Punkt 16: pusty -->
            <div class="point" data-position="21">
              <span class="point-number">21</span>
              <div class="triangle" id="point-21"></div>
            </div>
            <!-- Punkt 15: pusty -->
            <div class="point" data-position="22">
              <span class="point-number">22</span>
              <div class="triangle" id="point-22"></div>
            </div>
            <!-- Punkt 14: pusty -->
            <div class="point" data-position="23">
              <span class="point-number">23</span>
              <div class="triangle" id="point-23"></div>
            </div>
            <!-- Punkt 13: 5 białych pionków -->
            <div class="point" data-position="24">
              <span class="point-number">24</span>
              <div class="triangle" id="point-24"></div>
              <div class="piece white" data-position="24"></div>
              <div class="piece white" data-position="24"></div>
            </div>
          </div>
          
          <div class="divider"></div>
          
          <!-- Bottom row: punkty 12 do 1 (obracany o 180°) -->
          <div class="row bottom-row">
            <!-- Punkt 12: 5 czarnych pionków -->
            <div class="point" data-position="1">
              <span class="point-number">1</span>
              <div class="triangle" id="point-1"></div>
              <div class="bottom-pieces">
                <div class="piece black" data-position="1"></div>
                <div class="piece black" data-position="1"></div>
              </div>
            </div>
            <!-- Punkt 11: pusty -->
            <div class="point" data-position="2">
              <span class="point-number">2</span>
              <div class="triangle" id="point-2"></div>
              <div class="bottom-pieces">

              </div>
            </div>
            <!-- Punkt 10: pusty -->
            <div class="point" data-position="3">
              <span class="point-number">3</span>
              <div class="triangle" id="point-3"></div>
              <div class="bottom-pieces">
                
              </div>
            </div>
            <!-- Punkt 9: pusty -->
            <div class="point" data-position="4">
              <span class="point-number">4</span>
              <div class="triangle" id="point-4"></div>
              <div class="bottom-pieces">

              </div>
            </div>
            <!-- Punkt 8: 3 białe pionki -->
            <div class="point" data-position="5">
              <span class="point-number">5</span>
              <div class="triangle" id="point-5"></div>
              <div class="bottom-pieces">

              </div>
              
            </div>
            <!-- Punkt 7: pusty -->
            <div class="point" data-position="6">
              <span class="point-number">6</span>
              <div class="triangle" id="point-6"></div>
              <div class="bottom-pieces">
                <div class="piece white" data-position="6"></div>
                <div class="piece white" data-position="6"></div>
                <div class="piece white" data-position="6"></div>
                <div class="piece white" data-position="6"></div>
                <div class="piece white" data-position="6"></div>
              </div>
            </div>
            <!-- Punkt 6: 5 białych pionków -->
            <div class="point" data-position="7">
              <span class="point-number">7</span>
              <div class="triangle" id="point-7"></div>
              <div class="bottom-pieces">
                
              </div>
            </div>
            <!-- Punkt 5: pusty -->
            <div class="point" data-position="8">
              <span class="point-number">8</span>
              <div class="triangle" id="point-8"></div>
              <div class="bottom-pieces">
                <div class="piece white" data-position="8"></div>
                <div class="piece white" data-position="8"></div>
                <div class="piece white" data-position="8"></div>
              </div>
            </div>
            <!-- Punkt 4: pusty -->
            <div class="point" data-position="9">
              <span class="point-number">9</span>
              <div class="triangle" id="point-9"></div>
              <div class="bottom-pieces">

              </div>
            </div>
            <!-- Punkt 3: pusty -->
            <div class="point" data-position="10">
              <span class="point-number">10</span>
              <div class="triangle" id="point-10"></div>
              <div class="bottom-pieces">

              </div>
            </div>
            <!-- Punkt 2: pusty -->
            <div class="point" data-position="11">
              <span class="point-number">11</span>
              <div class="triangle" id="point-11"></div>
              <div class="bottom-pieces">

              </div>
            </div>
            <!-- Punkt 1: 2 czarne pionki -->
            <div class="point" data-position="12">
              <span class="point-number">12</span>
              <div class="triangle" id="point-12"></div>
              <div class="bottom-pieces">
                <div class="piece black" data-position="12"></div>
                <div class="piece black" data-position="12"></div>
                <div class="piece black" data-position="12"></div>
                <div class="piece black" data-position="12"></div>
                <div class="piece black" data-position="12"></div>
              </div>
            </div>
          </div>
        </div>
        <div class="bok">
        <!-- Kostki (dice) obok planszy -->
         <div id="home1" class = "home-area">
          <h3>Dom gracza 2</h3>
        </div>
        <div id="home2" class = "home-area">
          <h3>Dom gracza 1</h3>
        </div>
      </div>
      </div>
      
      <script>

     document.addEventListener('DOMContentLoaded', () => {
    console.log('Skrypt JavaScript został wczytany');
    

    let selectedPiece = null;
    let selectedPoint = null;
    let currentPlayer = "1"; // Player 1 starts
    let availableMoves = [];
    let dice1 = 0, dice2 = 0;
    let diceRolled = false;

    updateTurnIndicator(currentPlayer);

     // **Add Click Event for Home Areas**
     document.getElementById("home2").addEventListener("click", () => {
        if (currentPlayer !== "1") {
            alert("To nie jest twój dom!");
            return;
        }
        attemptBearOff("1");
    });

    document.getElementById("home1").addEventListener("click", () => {
        if (currentPlayer !== "2") {
            alert("To nie jest twój dom!");
            return;
        }
        attemptBearOff("2");
    });

     // **End Turn Button**
     document.getElementById("end-turn-btn").addEventListener("click", () => {
        alert(`Gracz ${currentPlayer} zakończył swoją turę.`);
        switchTurn(); // **Switch player turn**
    });

    // **Function to Handle Bearing Off**
    function attemptBearOff(player) {
    if (!player) {
        console.error("Błąd: player jest niezdefiniowany!");
        return;
    }

    let homeArea = document.getElementById(player === "1" ? "home2" : "home1");
    let homeStart = player === "1" ? 1 : 19;
    let homeEnd = player === "1" ? 6 : 24;

    // **Check if all pieces are in the home area**
    let allPiecesHome = true;
    document.querySelectorAll('.piece').forEach(piece => {
        let pieceColor = piece.classList.contains('white') ? "1" : "2";
        let position = parseInt(piece.dataset.position);

        if (pieceColor === player && (position < homeStart || position > homeEnd)) {
            allPiecesHome = false;
        }
    });

    if (!allPiecesHome) {
        alert("Nie możesz jeszcze usuwać pionków! Wszystkie twoje pionki muszą być w strefie domu.");
        return;
    }

    if (!selectedPiece) {
        alert("Wybierz pionek, który chcesz usunąć do domu!");
        return;
    }

    let pieceColor = selectedPiece.classList.contains("white") ? "1" : "2";
    if (pieceColor !== player) {
        alert("Nie możesz usunąć pionka przeciwnika!");
        return;
    }

    let piecePosition = parseInt(selectedPiece.dataset.position);
    let move_value = homeEnd - piecePosition; // Calculate how far the piece moves off the board

    if (!availableMoves.includes(move_value)) {
        // **Allow bearing off if no exact dice match, but only from the highest position**
        let maxAvailableMove = Math.max(...availableMoves);
        if (piecePosition === homeStart && maxAvailableMove > piecePosition) {
            move_value = maxAvailableMove;
        } else {
            alert(`Musisz użyć kości, aby zdjąć pionek z pozycji ${piecePosition}!`);
            return;
        }
    }

    // **Remove the used move from availableMoves**
    availableMoves.splice(availableMoves.indexOf(move_value), 1);

    // **Count as a move**
    moveCount++;

    // **Move piece to home area visually**
    let pieceCount = homeArea.querySelectorAll('.piece').length;
    let offsetX = (pieceCount % 5) * 30;
    let offsetY = Math.floor(pieceCount / 5) * 30;

    selectedPiece.style.position = "absolute";
    selectedPiece.style.left = `${offsetX}px`;
    selectedPiece.style.top = `${offsetY}px`;

    homeArea.appendChild(selectedPiece);
    selectedPiece.dataset.position = "home";

    alert(`Gracz ${player} usunął pionek do domu!`);

    selectedPiece = null;

    // **Check if turn should end**
    checkTurnEnd();
}


    document.querySelectorAll('.dice').forEach(die => {
    die.addEventListener('click', () => {
        if (diceRolled) {
            alert("Możesz rzucić kostką tylko raz na turę!");
            return;
        }

        // **Fetch new dice values from the server**
        fetch('/roll-dice', { method: "POST" })
            .then(response => response.json())
            .then(data => {
                dice1 = data.dice1;
                dice2 = data.dice2;
                document.getElementById("die1").textContent = dice1;
                document.getElementById("die2").textContent = dice2;
                availableMoves = [dice1, dice2, dice1 + dice2];

                diceRolled = true; // **Now dice can't be rolled again this turn**
                console.log(`Gracz ${currentPlayer} rzucił: ${dice1}, ${dice2} (dostępne ruchy: ${availableMoves.join(', ')})`);
            })
            .catch(error => console.error("Błąd podczas pobierania rzutów kostką:", error));
    });
});

// **Switch Turn Function**
function switchTurn() {
        currentPlayer = currentPlayer === "1" ? "2" : "1";
        diceRolled = false;
        availableMoves = [];
        updateTurnIndicator(currentPlayer);
        alert(`Teraz ruch ma gracz ${currentPlayer}`);
    }

    function attemptReEntry() {
    let capturedPieces = document.querySelectorAll(`#captured-pieces .piece.${currentPlayer === "1" ? "white" : "black"}`);

    if (capturedPieces.length === 0) {
        return; // No captured pieces, player can move normally
    }



    let entryPoints = currentPlayer === "2" ? [dice1, dice2] : [25 - dice1, 25 - dice2]; // Convert dice rolls to opponent's home board positions
let validPoints = [];

for (let entryPoint of entryPoints) {
    let targetPoint = document.querySelector(`.point[data-position="${entryPoint}"]`);
    if (!targetPoint) continue; // Skip if invalid

    // **Check if there's a `.bottom-pieces` container inside**
    let bottomContainer = targetPoint.querySelector(".bottom-pieces");
    let finalTarget = bottomContainer ? bottomContainer : targetPoint; // Use bottom-pieces if it exists

    let piecesAtTarget = finalTarget.querySelectorAll(".piece");

    // **Check if spot is completely empty**
    if (piecesAtTarget.length === 0) {
        validPoints.push(finalTarget); // Add as a valid placement spot
    }
}

if (validPoints.length === 0) {
    alert("Nie można wprowadzić pionka, wszystkie wejścia są zajęte. Tura przepada.");
    switchTurn();
    return;
}

// **Allow player to click on a captured piece to place it**
capturedPieces.forEach(piece => {
    piece.addEventListener("click", () => {
        
        let selectedPiece = piece;

        // **Highlight valid points**
        validPoints.forEach(point => {
            point.classList.add("highlight"); // Add a highlight class to show valid moves
            point.addEventListener("click", () => {
                // **Move piece to selected point**
                point.appendChild(selectedPiece);
                selectedPiece.dataset.position = point.closest(".point").getAttribute("data-position"); // Get correct position

                // **Remove highlight**
                validPoints.forEach(p => p.classList.remove("highlight"));

                // **Remove the used move from availableMoves**
                let moveUsed = Math.abs(parseInt(point.closest(".point").getAttribute("data-position")) - (currentPlayer === "1" ? 1 : 24));
                let moveIndex = availableMoves.indexOf(moveUsed);
                if (moveIndex !== -1) availableMoves.splice(moveIndex, 1);

                // **Check if turn should end**
                if (capturedPieces.length - 1 === 0 && availableMoves.length === 0) {
                    switchTurn();
                }
            }, { once: true }); // Make sure it only triggers once
        });
    }, { once: true }); // Ensure each captured piece is clickable only once
});

}


    // Selecting a piece to move
    let player = currentPlayer; 
    let homeStart = player === "1" ? 1 : 19;
    let homeEnd = player === "1" ? 6 : 24;
    

    let allPiecesHome = true;
    document.querySelectorAll('.piece').forEach(piece => {
      let pieceColor = piece.classList.contains('white') ? "1" : "2";
      let position = parseInt(piece.dataset.position);

      if (pieceColor === player && (position < homeStart || position > homeEnd)){
        allPiecesHome = false;
      }

        piece.addEventListener('click', (e) => {
            e.stopPropagation();
            
            const pieceColor = piece.classList.contains('white') ? "1" : "2";

             // **Check if the clicked piece is in the captured area**
        let isCaptured = piece.closest("#captured-pieces") !== null;
            
            if (pieceColor !== currentPlayer) {
                alert("Nie możesz ruszyć pionka przeciwnika!");
                return;
            }

            //**Check if the player has captured pieces
            let capturedPieces = document.querySelectorAll(`#captured-pieces .piece.${currentPlayer === "1" ? "white" : "black"}`);
            if (isCaptured) {
            attemptReEntry();
            return; // Allow re-entry, block all other moves
            }

            if (capturedPieces.length > 0) {
            alert("Musisz najpierw wyprowadzić pionek z pola zbitych!");
            return;
            }
            

            const pointElem = piece.closest('.point');
            if (!pointElem){
              console.error("Błąd: Nie można znależć punktu dla pionka")
              return;
            }

            

            
            document.querySelectorAll('.point').forEach(p => p.classList.remove('selected'));
            pointElem.classList.add('selected');
            
            selectedPoint = parseInt(pointElem.getAttribute('data-position'));
            selectedPiece = piece;
            console.log(`Gracz ${currentPlayer} wybrał pionek z punktu: ${selectedPoint}`);
        });
    });

    // Handling piece movement
    document.querySelectorAll('.point').forEach(point => {
    point.addEventListener('click', () => {
        const dest = parseInt(point.getAttribute('data-position'));
        if (!selectedPiece || selectedPoint === null) {
            console.log('Najpierw wybierz pionek do przesunięcia.');
            return;
        }

        let move_value = Math.abs(selectedPoint - dest);
        console.log(`Obliczona wartość ruchu: ${move_value}`);

        if (!availableMoves.includes(move_value)) {
            alert(`Ruch nie odpowiada dostępnych wartościom kostek: ${availableMoves.join(", ")}`);
            return;
        }

        const pieceColor = selectedPiece.classList.contains('white') ? "1" : "2";

        if ((pieceColor === "1" && dest > selectedPoint) || (pieceColor === "2" && dest < selectedPoint)) {
            alert("Nie możesz ruszyć się wstecz!");
            return;
        }

         // **Check if the piece is eligible to be moved to home**
         if ((pieceColor === "1" && dest === 0 && selectedPoint <= 6) || 
            (pieceColor === "2" && dest === 25 && selectedPoint >= 19)) {
            movePieceToHome(selectedPiece, pieceColor);
            return;
        }

         // **Check if bearing off instead of moving**
         if ((currentPlayer === "1" && dest === 0) || (currentPlayer === "2" && dest === 25)) {
            attemptBearOff(player);
            return;
        }

        // **Check movement direction
        // **if ((pieceColor === "1" && dest >= selectedPoint) || (pieceColor === "2" && dest <= selectedPoint)) {**
            // **alert("Nie możesz przesunąć pionka w tym kierunku!");**
            //**return;**
        // **}**

        const bottomPiecesContainer = point.querySelector('.bottom-pieces');
        const targetContainer = bottomPiecesContainer ? bottomPiecesContainer : point;

        // **Check if the target has 2+ opponent pieces (blocked)**
        const existingPieces = targetContainer.querySelectorAll('.piece');
        if (existingPieces.length >= 2 && existingPieces[0]) {
            const existingPieceColor = existingPieces[0].classList.contains('white') ? "1" : "2";
            
            if (existingPieceColor !== pieceColor) {
                alert("Nie możesz wejść na pole, gdzie przeciwnik ma 2 lub więcej pionków!");
                return;
            }
        }

        // **Check if there's a single opponent piece (capture condition)**
        if (existingPieces.length === 1) {
            const existingPiece = existingPieces[0];
            const existingPieceColor = existingPiece.classList.contains('white') ? "1" : "2";

            if (existingPieceColor !== pieceColor) {
                alert("Złapano pionek przeciwnika!");
                sendPieceToCapturedArea(existingPiece);
            }
        }

        // **Check if target has space for more pieces**
        if (targetContainer.querySelectorAll('.piece').length >= 5) {
            alert("Na tym polu jest już 5 pionków. Nie można tam dodać więcej.");
            return;
        }

        if (availableMoves.includes(dice1 + dice2) && move_value !== (dice1 + dice2)) {
            console.log("Pierwszy ruch nie wykorzystał sumy kostek. Usuwam tę opcję.");
            availableMoves = availableMoves.filter(value => value !== (dice1 + dice2));
        }
        if (availableMoves.includes(dice1 + dice2) && move_value == (dice1 + dice2)) {
            availableMoves = availableMoves.filter(value => value == (dice1 + dice2));
        }
        
        fetch('/move', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ start: selectedPoint, end: dest, player: currentPlayer, move_value: move_value, dice1Python: dice1, dice2Python: dice2 })
        })
        .then(response => {
          console.log("Full server response:", response);

          if (!response.ok){
            return response.text().then(errorText => {
              console.error("Serwer error", errorTest);
              throw new Error(`Błąd serwera: ${errorText}`);
            });
          }
          return response.json().then(data => {
            console.log("JSON data reveived:", data);
            return data;
          }).catch(err => {
            console.error("Błąd: Serwer nie zwrócił poprawnego JSON", err);
            throw new Error("Błą: Serwe nie zwrócił poprawnego JSON");
          });
        })
        .then(data => {
    console.log("Debugging: Full data received from server:", data);

    if (!data || typeof data !== "object") {
        throw new Error("Błąd: Serwer nie zwrócił poprawnej odpowiedzi (brak danych lub nieprawidłowy format).");
    }

    if (!data.message) {
        throw new Error("Błąd: Brak oczekiwanej odpowiedzi z serwera.");
    }

            alert(data.message);
            movePiece(selectedPiece, point);

            const idx = availableMoves.indexOf(move_value);
            if (idx !== -1) availableMoves.splice(idx, 1);

            console.log(`Pozostałe dostępne ruchy po wykonaniu: ${availableMoves.join(", ")}`);

            if (availableMoves.length === 0) {
                alert(`Tura gracza ${currentPlayer} zakończona.`);
                currentPlayer = currentPlayer === "1" ? "2" : "1";
                diceRolled = false;
                updateTurnIndicator(currentPlayer);
                alert(`Teraz ruch ma gracz ${currentPlayer}`);
            }

            selectedPiece = null;
            selectedPoint = null;
            document.querySelectorAll('.point').forEach(p => p.classList.remove('selected'));
        })
        .catch(err => console.error('Błąd:', err.message));
    });
});

// **Move Piece to Home Function**
function movePieceToHome(piece, player) {
    const homeArea = document.getElementById(player === "1" ? "home1" : "home2");
    homeArea.appendChild(piece);
    piece.dataset.position = "home";
    alert(`Gracz ${player} usunął pionek do domu!`);
}

// **Function to send captured piece to the captured area**
function sendPieceToCapturedArea(piece) {
    const capturedArea = document.getElementById("captured-pieces");
    capturedArea.appendChild(piece);
    piece.dataset.position = "captured";
}

});

// Function to move a piece
function movePiece(piece, targetPoint) {
    const bottomPiecesContainer = targetPoint.querySelector('.bottom-pieces');
    const targetContainer = bottomPiecesContainer ? bottomPiecesContainer : targetPoint;

    const rect1 = piece.getBoundingClientRect();
    const rect2 = targetContainer.getBoundingClientRect();

    const deltaX = rect2.left - rect1.left;
    const deltaY = rect2.top - rect1.top;

    piece.style.transition = 'transform 0.3s ease-in-out';
    piece.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

    setTimeout(() => {
        targetContainer.appendChild(piece);
        piece.style.transition = '';
        piece.style.transform = '';
        piece.dataset.position = targetPoint.getAttribute('data-position');
    }, 300);
}
function updateTurnIndicator(currentPlayer) {
    const turnIndicator = document.getElementById("turn-indicator");
    if (currentPlayer === "1") {
        turnIndicator.textContent = "Tura gracza: 1 (Białe)";
    } else {
        turnIndicator.textContent = "Tura gracza: 2 (Czarne)";
    }
}
   

      </script>
      
      
      
    </body>
    </html>